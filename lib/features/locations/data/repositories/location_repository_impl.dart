import 'package:dartz/dartz.dart';
import '../../../../core/error/exceptions.dart';
import '../../../../core/error/failures.dart';
import '../../../../core/network/network_info.dart';
import '../../domain/entities/user_location_entity.dart';
import '../../domain/repositories/location_repository.dart';
import '../datasources/location_remote_data_source.dart';
import '../models/user_location_model.dart';

class LocationRepositoryImpl implements LocationRepository {
  final LocationRemoteDataSource remoteDataSource;
  final NetworkInfo networkInfo;

  LocationRepositoryImpl({
    required this.remoteDataSource,
    required this.networkInfo,
  });

  @override
  Future<Either<Failure, List<UserLocationEntity>>> getMyLocations(
      String userId) async {
    if (await networkInfo.isConnected) {
      try {
        final locations = await remoteDataSource.getUserLocations(userId);
        return Right(locations);
      } on ServerException {
        return Left(ServerFailure('Error al obtener ubicaciones'));
      }
    } else {
      return Left(ServerFailure('Sin conexión a internet'));
    }
  }

  @override
  Future<Either<Failure, void>> createLocation({
    required String userId,
    required LocationLabel label,
    required LocationPurpose purpose,
    String? address,
    String? city,
    String? neighborhood,
    double? latitude,
    double? longitude,
  }) async {
    if (await networkInfo.isConnected) {
      try {
        final locationModel = UserLocationModel(
          id: '', // Generated by DB
          userId: userId,
          label: label,
          purpose: purpose,
          address: address,
          city: city,
          neighborhood: neighborhood,
          latitude: latitude,
          longitude: longitude,
          isPrimary: false,
          createdAt: DateTime.now(), // Generated by DB
          updatedAt: DateTime.now(), // Generated by DB
        );

        await remoteDataSource.createLocation(locationModel);
        return Right(null);
      } on ServerException {
        return Left(ServerFailure('Error al crear ubicación'));
      } catch (e) {
        return Left(ServerFailure(e.toString()));
      }
    } else {
      return Left(ServerFailure('Sin conexión a internet'));
    }
  }

  @override
  Future<Either<Failure, void>> updateLocation({
    required String locationId,
    required LocationLabel label,
    required LocationPurpose purpose,
    String? address,
    String? city,
    String? neighborhood,
    double? latitude,
    double? longitude,
  }) async {
    if (!await networkInfo.isConnected) {
      return Left(NetworkFailure('Sin conexión a internet'));
    }

    try {
      final locationModel = UserLocationModel(
        id: locationId,
        userId: '', // Not needed for update
        label: label,
        purpose: purpose,
        address: address,
        city: city,
        neighborhood: neighborhood,
        latitude: latitude,
        longitude: longitude,
        isPrimary: false,
        createdAt: DateTime.now(), // Not needed
        updatedAt: DateTime.now(),
      );

      await remoteDataSource.updateLocation(locationModel);
      return Right(null);
    } on ServerException {
      return Left(ServerFailure('Error al actualizar ubicación'));
    } catch (e) {
      return Left(ServerFailure(e.toString()));
    }
  }
}
